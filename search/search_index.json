{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"autocrop Perfect for profile picture processing for your website or batch work for ID cards, autocrop will output images centered around the biggest face detected. Installation Simple! pip install autocrop Use Autocrop can be used from the command line or directly from Python API . From Python Import the Cropper class, set some parameters (optional), and start cropping. The crop method accepts filepaths or np.ndarray , and returns Numpy arrays. These are easily handled with PIL or Matplotlib . from PIL import Image from autocrop import Cropper cropper = Cropper () # Get a Numpy array of the cropped image cropped_array = cropper . crop ( 'portrait.png' ) # Save the cropped image with PIL if a face was detected: if cropped_array : cropped_image = Image . fromarray ( cropped_array ) cropped_image . save ( 'cropped.png' ) Further examples and use cases are found in the accompanying Jupyter Notebook . From the command line usage : autocrop [- h ] [- v ] [-- no - confirm ] [- n ] [- i INPUT ] [- o OUTPUT ] [- r REJECT ] [- w WIDTH ] [- H HEIGHT ] [-- facePercent FACEPERCENT ] [- e EXTENSION ] Automatically crops faces from batches of pictures options : - h , -- help Show this help message and exit - v , -- version Show program 's version number and exit --no-confirm Bypass any confirmation prompts -n, --no-resize Do not resize images to the specified width and height, but instead use the original image' s pixels . - i , -- input INPUT Folder where images to crop are located . Default : current working directory - o , - p , -- output , -- path OUTPUT Folder where cropped images will be moved to . Default : current working directory , meaning images are cropped in place . - r , -- reject REJECT Folder where images that could not be cropped will be moved to . Default : current working directory , meaning images that are not cropped will be left in place . - w , -- width WIDTH Width of cropped files in px . Default = 500 - H , -- height HEIGHT Height of cropped files in px . Default = 500 -- facePercent FACEPERCENT Percentage of face to image height - e , -- extension EXTENSION Enter the image extension which to save at output Examples Crop every image in the pics folder, resize them to 400 px squares, and output them in the crop directory: autocrop -i pics -o crop -w 400 -H 400 . Images where a face can't be detected will be left in crop . Same as above, but output the images with undetected faces to the reject directory: autocrop -i pics -o crop -r reject -w 400 -H 400 . Same as above but the image extension will be png : autocrop -i pics -o crop -w 400 -H 400 -e png Crop every image in the pics folder and output to the crop directory, but keep the original pixels from the images: autocrop -i pics -o crop --no-resize If no output folder is added, asks for confirmation and destructively crops images in-place. Detecting faces from video files You can use autocrop to detect faces in frames extracted from a video. A great way to perform the frame extraction step is with ffmpeg : mkdir frames faces # Extract one frame per second ffmpeg -i input.mp4 -filter:v fps = fps = 1 /60 frames/ffmpeg_%0d.bmp # Crop faces as jpg autocrop -i frames -o faces -e jpg Supported file types The following file types are supported: EPS files ( .eps ) GIF files ( .gif ) (only the first frame of an animated GIF is used) JPEG 2000 files ( .j2k , .j2p , .jp2 , .jpx ) JPEG files ( .jpeg , .jpg , .jpe ) LabEye IM files ( .im ) macOS ICNS files ( .icns ) Microsoft Paint bitmap files ( .msp ) PCX files ( .pcx ) Portable Network Graphics ( .png ) Portable Pixmap files ( .pbm , .pgm , .ppm ) SGI files ( .sgi ) SPIDER files ( .spi ) TGA files ( .tga ) TIFF files ( .tif , .tiff ) WebP ( .webp ) Windows bitmap files ( .bmp , .dib ) Windows ICO files ( .ico ) X bitmap files ( .xbm ) Misc Installing directly In some cases, you may wish the package directly, instead of through PyPI : cd ~ git clone https://github.com/leblancfg/autocrop cd autocrop pip install . conda Development of a conda-forge package for the Anaconda Python distribution is currently stalled due to the complexity of setting up the workflow with OpenCV. Please leave feedback on issue #7 to see past attempts if you are insterested in helping out! Requirements Best practice for your projects is of course to use virtual environments . At the very least, you will need to have pip installed . Autocrop is currently being tested on : Python 3.7 to 3.10 OS: Linux macOS Windows More Info Check out: http://docs.opencv.org/master/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0 http://docs.opencv.org/master/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0 Adapted from: http://photo.stackexchange.com/questions/60411/how-can-i-batch-crop-based-on-face-location Contributing Although autocrop is essentially a CLI wrapper around a single OpenCV function, it is actively developed. It has active users throughout the world. If you would like to contribute, please consult the contribution docs .","title":"Home"},{"location":"#autocrop","text":"Perfect for profile picture processing for your website or batch work for ID cards, autocrop will output images centered around the biggest face detected.","title":"autocrop"},{"location":"#installation","text":"Simple! pip install autocrop","title":"Installation"},{"location":"#use","text":"Autocrop can be used from the command line or directly from Python API .","title":"Use"},{"location":"#from-python","text":"Import the Cropper class, set some parameters (optional), and start cropping. The crop method accepts filepaths or np.ndarray , and returns Numpy arrays. These are easily handled with PIL or Matplotlib . from PIL import Image from autocrop import Cropper cropper = Cropper () # Get a Numpy array of the cropped image cropped_array = cropper . crop ( 'portrait.png' ) # Save the cropped image with PIL if a face was detected: if cropped_array : cropped_image = Image . fromarray ( cropped_array ) cropped_image . save ( 'cropped.png' ) Further examples and use cases are found in the accompanying Jupyter Notebook .","title":"From Python"},{"location":"#from-the-command-line","text":"usage : autocrop [- h ] [- v ] [-- no - confirm ] [- n ] [- i INPUT ] [- o OUTPUT ] [- r REJECT ] [- w WIDTH ] [- H HEIGHT ] [-- facePercent FACEPERCENT ] [- e EXTENSION ] Automatically crops faces from batches of pictures options : - h , -- help Show this help message and exit - v , -- version Show program 's version number and exit --no-confirm Bypass any confirmation prompts -n, --no-resize Do not resize images to the specified width and height, but instead use the original image' s pixels . - i , -- input INPUT Folder where images to crop are located . Default : current working directory - o , - p , -- output , -- path OUTPUT Folder where cropped images will be moved to . Default : current working directory , meaning images are cropped in place . - r , -- reject REJECT Folder where images that could not be cropped will be moved to . Default : current working directory , meaning images that are not cropped will be left in place . - w , -- width WIDTH Width of cropped files in px . Default = 500 - H , -- height HEIGHT Height of cropped files in px . Default = 500 -- facePercent FACEPERCENT Percentage of face to image height - e , -- extension EXTENSION Enter the image extension which to save at output","title":"From the command line"},{"location":"#examples","text":"Crop every image in the pics folder, resize them to 400 px squares, and output them in the crop directory: autocrop -i pics -o crop -w 400 -H 400 . Images where a face can't be detected will be left in crop . Same as above, but output the images with undetected faces to the reject directory: autocrop -i pics -o crop -r reject -w 400 -H 400 . Same as above but the image extension will be png : autocrop -i pics -o crop -w 400 -H 400 -e png Crop every image in the pics folder and output to the crop directory, but keep the original pixels from the images: autocrop -i pics -o crop --no-resize If no output folder is added, asks for confirmation and destructively crops images in-place.","title":"Examples"},{"location":"#detecting-faces-from-video-files","text":"You can use autocrop to detect faces in frames extracted from a video. A great way to perform the frame extraction step is with ffmpeg : mkdir frames faces # Extract one frame per second ffmpeg -i input.mp4 -filter:v fps = fps = 1 /60 frames/ffmpeg_%0d.bmp # Crop faces as jpg autocrop -i frames -o faces -e jpg","title":"Detecting faces from video files"},{"location":"#supported-file-types","text":"The following file types are supported: EPS files ( .eps ) GIF files ( .gif ) (only the first frame of an animated GIF is used) JPEG 2000 files ( .j2k , .j2p , .jp2 , .jpx ) JPEG files ( .jpeg , .jpg , .jpe ) LabEye IM files ( .im ) macOS ICNS files ( .icns ) Microsoft Paint bitmap files ( .msp ) PCX files ( .pcx ) Portable Network Graphics ( .png ) Portable Pixmap files ( .pbm , .pgm , .ppm ) SGI files ( .sgi ) SPIDER files ( .spi ) TGA files ( .tga ) TIFF files ( .tif , .tiff ) WebP ( .webp ) Windows bitmap files ( .bmp , .dib ) Windows ICO files ( .ico ) X bitmap files ( .xbm )","title":"Supported file types"},{"location":"#misc","text":"","title":"Misc"},{"location":"#installing-directly","text":"In some cases, you may wish the package directly, instead of through PyPI : cd ~ git clone https://github.com/leblancfg/autocrop cd autocrop pip install .","title":"Installing directly"},{"location":"#conda","text":"Development of a conda-forge package for the Anaconda Python distribution is currently stalled due to the complexity of setting up the workflow with OpenCV. Please leave feedback on issue #7 to see past attempts if you are insterested in helping out!","title":"conda"},{"location":"#requirements","text":"Best practice for your projects is of course to use virtual environments . At the very least, you will need to have pip installed . Autocrop is currently being tested on : Python 3.7 to 3.10 OS: Linux macOS Windows","title":"Requirements"},{"location":"#more-info","text":"Check out: http://docs.opencv.org/master/d7/d8b/tutorial_py_face_detection.html#gsc.tab=0 http://docs.opencv.org/master/d5/daf/tutorial_py_histogram_equalization.html#gsc.tab=0 Adapted from: http://photo.stackexchange.com/questions/60411/how-can-i-batch-crop-based-on-face-location","title":"More Info"},{"location":"#contributing","text":"Although autocrop is essentially a CLI wrapper around a single OpenCV function, it is actively developed. It has active users throughout the world. If you would like to contribute, please consult the contribution docs .","title":"Contributing"},{"location":"CONTRIBUTING/","text":"Contributing All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Please follow these steps: Fork the autocrop repository to your personal GitHub account and clone it locally Install the development setup (see section below) Branch off of master for every change you want to make Develop changes on your branch Test your changes (see section below) Modify the tests and documentation as necessary When your changes are ready, make a pull request to the upstream autocrop repository Development Setup This project works with virtualenv . To start things off, run: $ python3 -m venv env $ source env/bin/activate Then, run: $ pip install -U setuptools $ pip install -r requirements-test.txt $ pip install -e . You can then run autocrop like so: $ autocrop As long as the virtual environment has been activated, this will command will use the files in your local Git checkout. This makes it super easy to work on the code and test your changes. To set up your virtual environment again in future, just run: $ source env/bin/activate Tests Pull requests are tested using continuous integration (CI) which will green-light changes. Specifically, we: Use flake8 for coding style tests Run a test suite using pytest You can run the tests locally, like so: $ make check Contact If you have any questions, please email me at leblancfg@gmail.com .","title":"Contributing"},{"location":"CONTRIBUTING/#contributing","text":"All contributions, bug reports, bug fixes, documentation improvements, enhancements, and ideas are welcome. Please follow these steps: Fork the autocrop repository to your personal GitHub account and clone it locally Install the development setup (see section below) Branch off of master for every change you want to make Develop changes on your branch Test your changes (see section below) Modify the tests and documentation as necessary When your changes are ready, make a pull request to the upstream autocrop repository","title":"Contributing"},{"location":"CONTRIBUTING/#development-setup","text":"This project works with virtualenv . To start things off, run: $ python3 -m venv env $ source env/bin/activate Then, run: $ pip install -U setuptools $ pip install -r requirements-test.txt $ pip install -e . You can then run autocrop like so: $ autocrop As long as the virtual environment has been activated, this will command will use the files in your local Git checkout. This makes it super easy to work on the code and test your changes. To set up your virtual environment again in future, just run: $ source env/bin/activate","title":"Development Setup"},{"location":"CONTRIBUTING/#tests","text":"Pull requests are tested using continuous integration (CI) which will green-light changes. Specifically, we: Use flake8 for coding style tests Run a test suite using pytest You can run the tests locally, like so: $ make check","title":"Tests"},{"location":"CONTRIBUTING/#contact","text":"If you have any questions, please email me at leblancfg@gmail.com .","title":"Contact"},{"location":"changelog/","text":"Autocrop changelog All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning . 1.3.1 - 2022-02-08 API Additions The Cropper class now accepts a resize arg, to determine whether to resize the image after cropping it or not. Similarly for the CLI, it can now be called with a --no-resize flag Other changes The order of CLI args when calling autocrop --help changed to place flags first Start using type hints across the codebase 1.3.0 - 2022-01-25 Changes The initial-setup step in Makefile now also installs development packages. The black formatting package now gets installed with requirements-dev.txt Deprecations Deprecate Python 3.6 1.2.0 - 2021-11-26 Changes Modify the opencv-python dependency over to opencv-python-headless , which doesn't have all the GUI baggage. Easier to download and package. Documentation Created the examples directory and moved the example notebook to it. 1.1.1 - 17-02-2021 Deprecations Deprecate Python 3.5 Deprecate OpenCV 3 API Additions User can now specify what file extension to save cropped files at the CLI Security Update Pillow dependency in order to limit possible security issues Other changes Updates to the developer setup tools and documentation Updates to the example notebook 1.1.0 - 24-10-2020 Added CLI now copies file by default 1.0.0 - 24-03-2020 Added Cropper class now available from Python API. Local multi-version testing for Python now available with tox . Extra regressions tests to defend against image warp and cropping outside the regions of interest. Support for Python 3.8 Bugfixes Specify encoding in setup.py , which was causing some errors on Windows. Deprecated Support for padding argument \u2014 this is now solely handled by the face_percent parameter, and enforces the aspect ratio between width and height . Support for Python 2.7 0.3.2 Changes Autocrop now prints the filename of images where face detection failed Internal refactoring and more tests 0.3.1 Changes Add -r , --reject flag to specify directory where the images that autocrop couldn't find a face in are directed to. Instead of having the target files copied then cropped, they are instead cropped and saved to their respective target folder. 0.3.0 Changes Added support for padding ( padLeft , etc.) in the CLI. Bugfix Fixed warp on crop for -w and -h values 0.2.0 Changes Add -o , --output flag to specify directory where cropped images are to be dumped. Error out if output folder set to current directory, i.e. -o . If directory doesn't exist yet, create it. If no face can be found in an image in batch, it is still copied over to -o folder. If no output folder is added, ask for confirmation ([Y]/n), and destructively crop images in-place. Use -i , --input flags as synonyms for -p or --path : symmetrical in meaning to \"output\". Is now standard nomenclature in documentation. --input or --path flag is now optional. Standard behaviour without input folder is to non-recursively process all images in immediate folder, i.e. -p . as currently implemented. Breaks Removed all mentions of the hard-coded 'bkp' and 'crop' folders Calling autocrop without specifying an input path, i.e. autocrop does not look for the 'images' folder anymore.","title":"Changelog"},{"location":"changelog/#autocrop-changelog","text":"All notable changes to this project will be documented in this file. The format is based on Keep a Changelog , and this project adheres to Semantic Versioning .","title":"Autocrop changelog"},{"location":"changelog/#131-2022-02-08","text":"","title":"1.3.1 - 2022-02-08"},{"location":"changelog/#api-additions","text":"The Cropper class now accepts a resize arg, to determine whether to resize the image after cropping it or not. Similarly for the CLI, it can now be called with a --no-resize flag","title":"API Additions"},{"location":"changelog/#other-changes","text":"The order of CLI args when calling autocrop --help changed to place flags first Start using type hints across the codebase","title":"Other changes"},{"location":"changelog/#130-2022-01-25","text":"","title":"1.3.0 - 2022-01-25"},{"location":"changelog/#changes","text":"The initial-setup step in Makefile now also installs development packages. The black formatting package now gets installed with requirements-dev.txt","title":"Changes"},{"location":"changelog/#deprecations","text":"Deprecate Python 3.6","title":"Deprecations"},{"location":"changelog/#120-2021-11-26","text":"","title":"1.2.0 - 2021-11-26"},{"location":"changelog/#changes_1","text":"Modify the opencv-python dependency over to opencv-python-headless , which doesn't have all the GUI baggage. Easier to download and package.","title":"Changes"},{"location":"changelog/#documentation","text":"Created the examples directory and moved the example notebook to it.","title":"Documentation"},{"location":"changelog/#111-17-02-2021","text":"","title":"1.1.1 - 17-02-2021"},{"location":"changelog/#deprecations_1","text":"Deprecate Python 3.5 Deprecate OpenCV 3","title":"Deprecations"},{"location":"changelog/#api-additions_1","text":"User can now specify what file extension to save cropped files at the CLI","title":"API Additions"},{"location":"changelog/#security","text":"Update Pillow dependency in order to limit possible security issues","title":"Security"},{"location":"changelog/#other-changes_1","text":"Updates to the developer setup tools and documentation Updates to the example notebook","title":"Other changes"},{"location":"changelog/#110-24-10-2020","text":"","title":"1.1.0 - 24-10-2020"},{"location":"changelog/#added","text":"CLI now copies file by default","title":"Added"},{"location":"changelog/#100-24-03-2020","text":"","title":"1.0.0 - 24-03-2020"},{"location":"changelog/#added_1","text":"Cropper class now available from Python API. Local multi-version testing for Python now available with tox . Extra regressions tests to defend against image warp and cropping outside the regions of interest. Support for Python 3.8","title":"Added"},{"location":"changelog/#bugfixes","text":"Specify encoding in setup.py , which was causing some errors on Windows.","title":"Bugfixes"},{"location":"changelog/#deprecated","text":"Support for padding argument \u2014 this is now solely handled by the face_percent parameter, and enforces the aspect ratio between width and height . Support for Python 2.7","title":"Deprecated"},{"location":"changelog/#032","text":"","title":"0.3.2"},{"location":"changelog/#changes_2","text":"Autocrop now prints the filename of images where face detection failed Internal refactoring and more tests","title":"Changes"},{"location":"changelog/#031","text":"","title":"0.3.1"},{"location":"changelog/#changes_3","text":"Add -r , --reject flag to specify directory where the images that autocrop couldn't find a face in are directed to. Instead of having the target files copied then cropped, they are instead cropped and saved to their respective target folder.","title":"Changes"},{"location":"changelog/#030","text":"","title":"0.3.0"},{"location":"changelog/#changes_4","text":"Added support for padding ( padLeft , etc.) in the CLI.","title":"Changes"},{"location":"changelog/#bugfix","text":"Fixed warp on crop for -w and -h values","title":"Bugfix"},{"location":"changelog/#020","text":"","title":"0.2.0"},{"location":"changelog/#changes_5","text":"Add -o , --output flag to specify directory where cropped images are to be dumped. Error out if output folder set to current directory, i.e. -o . If directory doesn't exist yet, create it. If no face can be found in an image in batch, it is still copied over to -o folder. If no output folder is added, ask for confirmation ([Y]/n), and destructively crop images in-place. Use -i , --input flags as synonyms for -p or --path : symmetrical in meaning to \"output\". Is now standard nomenclature in documentation. --input or --path flag is now optional. Standard behaviour without input folder is to non-recursively process all images in immediate folder, i.e. -p . as currently implemented.","title":"Changes"},{"location":"changelog/#breaks","text":"Removed all mentions of the hard-coded 'bkp' and 'crop' folders Calling autocrop without specifying an input path, i.e. autocrop does not look for the 'images' folder anymore.","title":"Breaks"},{"location":"reference/autocrop/","text":"Module autocrop Image cropping module for Python with face detection ==================================================== Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. View Source # -*- coding: utf-8 -*- # flake8: noqa import os import sys from .autocrop import Cropper from .cli import command_line_interface from .__version__ import __version__ __doc__ = \"\"\" Image cropping module for Python with face detection ==================================================== Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. \"\"\" # Inject vendored directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"vendor\" ]) ) sys . path . insert ( 0 , v_path ) # Inject patched directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"patched\" ]) ) sys . path . insert ( 0 , v_path ) if __name__ == \"__main__\" : command_line_interface () Sub-modules autocrop.autocrop autocrop.cli autocrop.constants Variables v_path","title":"Index"},{"location":"reference/autocrop/#module-autocrop","text":"Image cropping module for Python with face detection ==================================================== Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. View Source # -*- coding: utf-8 -*- # flake8: noqa import os import sys from .autocrop import Cropper from .cli import command_line_interface from .__version__ import __version__ __doc__ = \"\"\" Image cropping module for Python with face detection ==================================================== Autocrop is a Python module that provides a simple and efficient method of cropping images of people around their faces. See https://leblancfg.com/autocrop for more documentation. \"\"\" # Inject vendored directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"vendor\" ]) ) sys . path . insert ( 0 , v_path ) # Inject patched directory into system path. v_path = os . path . abspath ( os . path . sep . join ([ os . path . dirname ( os . path . realpath ( __file__ )), \"patched\" ]) ) sys . path . insert ( 0 , v_path ) if __name__ == \"__main__\" : command_line_interface ()","title":"Module autocrop"},{"location":"reference/autocrop/#sub-modules","text":"autocrop.autocrop autocrop.cli autocrop.constants","title":"Sub-modules"},{"location":"reference/autocrop/#variables","text":"v_path","title":"Variables"},{"location":"reference/autocrop/autocrop/","text":"Module autocrop.autocrop None None View Source import itertools import cv2 import numpy as np import os import sys from PIL import Image from .constants import ( MINFACE , GAMMA_THRES , GAMMA , CV2_FILETYPES , PILLOW_FILETYPES , CASCFILE , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type.\"\"\" pass def perp ( a ): b = np . empty_like ( a ) b [ 0 ] = - a [ 1 ] b [ 1 ] = a [ 0 ] return b def intersect ( v1 , v2 ): a1 , a2 = v1 b1 , b2 = v2 da = a2 - a1 db = b2 - b1 dp = a1 - b1 dap = perp ( da ) denom = np . dot ( dap , db ) . astype ( float ) num = np . dot ( dap , dp ) return ( num / denom ) * db + b1 def distance ( pt1 , pt2 ): \"\"\"Returns the euclidian distance in 2D between 2 pts.\"\"\" distance = np . linalg . norm ( pt2 - pt1 ) return distance def bgr_to_rbg ( img ): \"\"\"Given a BGR (cv2) numpy array, returns a RBG (standard) array.\"\"\" dimensions = len ( img . shape ) if dimensions == 2 : return img return img [ ... , :: - 1 ] def gamma ( img , correction ): \"\"\"Simple gamma correction to brighten faces\"\"\" img = cv2 . pow ( img / 255.0 , correction ) return np . uint8 ( img * 255 ) def check_underexposed ( image , gray ): \"\"\" Returns the (cropped) image with GAMMA applied if underexposition is detected. \"\"\" uexp = cv2 . calcHist ([ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ]) if sum ( uexp [ - 26 :]) < GAMMA_THRES * sum ( uexp ): image = gamma ( image , GAMMA ) return image def check_positive_scalar ( num ): \"\"\"Returns True if value if a positive scalar.\"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ): return int ( num ) raise ValueError ( \"A positive scalar is required\" ) def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ] . lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None class Cropper : \"\"\" Crops the largest detected face from images. This class uses the `CascadeClassifier` from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- * `width` : `int`, default=500 - The width of the resulting array. * `height` : `int`, default=`500` - The height of the resulting array. * `face_percent`: `int`, default=`50` - Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. * `fix_gamma`: `bool`, default=`True` - Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. * `resize`: `bool`, default=`True` - Resizes the image to the specified width and height, otherwise, returns the original image pixels. \"\"\" def __init__ ( self , width = 500 , height = 500 , face_percent = 50 , padding = None , fix_gamma = True , resize = True , ): self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) self . aspect_ratio = width / height self . gamma = fix_gamma self . resize = resize # Face percent if face_percent > 100 or face_percent < 1 : fp_error = \"The face_percent argument must be between 1 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ): \"\"\" Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- - `path_or_array` : {`str`, `np.ndarray`} * The filepath or numpy array of the image. Returns ------- - `image` : {`np.ndarray`, `None`} * A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h , ) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize if self . resize : image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition fix if self . gamma : image = check_underexposed ( image , gray ) return bgr_to_rbg ( image ) def _determine_safe_zoom ( self , imgh , imgw , x , y , w , h ): \"\"\" Determines the safest zoom level with which to add margins around the detected face. Tries to honor `self.face_percent` when possible. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face Diagram: -------- i / j := zoom / 100 + h1 | h2 +---------|---------+ | MAR|GIN | | (x+w, y+h)| | +-----|-----+ | | | FA|CE | | | | | | | | \u251c\u2500\u2500i\u2500\u2500\u2524 | | | | cen|ter | | | | | | | | +-----|-----+ | | (x, y)| | | | | +---------|---------+ \u251c\u2500\u2500\u2500\u2500j\u2500\u2500\u2500\u2500\u2524 + \"\"\" # Find out what zoom factor to use given self.aspect_ratio corners = itertools . product (( x , x + w ), ( y , y + h )) center = np . array ([ x + int ( w / 2 ), y + int ( h / 2 )]) i = np . array ( [( 0 , 0 ), ( 0 , imgh ), ( imgw , imgh ), ( imgw , 0 ), ( 0 , 0 )] ) # image_corners image_sides = [( i [ n ], i [ n + 1 ]) for n in range ( 4 )] corner_ratios = [ self . face_percent ] # Hopefully we use this one for c in corners : corner_vector = np . array ([ center , c ]) a = distance ( * corner_vector ) intersects = list ( intersect ( corner_vector , side ) for side in image_sides ) for pt in intersects : if ( pt >= 0 ) . all () and ( pt <= i [ 2 ]) . all (): # if intersect within image dist_to_pt = distance ( center , pt ) corner_ratios . append ( 100 * a / dist_to_pt ) return max ( corner_ratios ) def _crop_positions ( self , imgh , imgw , x , y , w , h , ): \"\"\" Retuns the coordinates of the crop position centered around the detected face with extra margins. Tries to honor `self.face_percent` if possible, else uses the largest margins that comply with required aspect ratio given by `self.height` and `self.width`. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face \"\"\" zoom = self . _determine_safe_zoom ( imgh , imgw , x , y , w , h ) # Adjust output height based on percent if self . height >= self . width : height_crop = h * 100.0 / zoom width_crop = self . aspect_ratio * float ( height_crop ) else : width_crop = w * 100.0 / zoom height_crop = float ( width_crop ) / self . aspect_ratio # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = x - xpad h2 = x + w + xpad v1 = y - ypad v2 = y + h + ypad return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )] Variables CASCFILE COMBINED_FILETYPES CV2_FILETYPES GAMMA GAMMA_THRES INPUT_FILETYPES MINFACE PILLOW_FILETYPES Functions bgr_to_rbg def bgr_to_rbg ( img ) Given a BGR (cv2) numpy array, returns a RBG (standard) array. View Source def bgr_to_rbg ( img ) : \"\"\"Given a BGR (cv2) numpy array, returns a RBG (standard) array.\"\"\" dimensions = len ( img . shape ) if dimensions == 2 : return img return img [..., ::- 1 ] check_positive_scalar def check_positive_scalar ( num ) Returns True if value if a positive scalar. View Source def check_positive_scalar ( num ) : \"\"\" Returns True if value if a positive scalar. \"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ) : return int ( num ) raise ValueError ( \" A positive scalar is required \" ) check_underexposed def check_underexposed ( image , gray ) Returns the (cropped) image with GAMMA applied if underexposition is detected. View Source def check_underexposed ( image , gray ) : \"\"\" Returns the (cropped) image with GAMMA applied if underexposition is detected. \"\"\" uexp = cv2 . calcHist ( [ gray ] , [ 0 ] , None , [ 256 ] , [ 0, 256 ] ) if sum ( uexp [ -26: ] ) < GAMMA_THRES * sum ( uexp ) : image = gamma ( image , GAMMA ) return image distance def distance ( pt1 , pt2 ) Returns the euclidian distance in 2D between 2 pts. View Source def distance ( pt1 , pt2 ) : \"\"\" Returns the euclidian distance in 2D between 2 pts. \"\"\" distance = np . linalg . norm ( pt2 - pt1 ) return distance gamma def gamma ( img , correction ) Simple gamma correction to brighten faces View Source def gamma ( img , correction ) : \"\"\" Simple gamma correction to brighten faces \"\"\" img = cv2 . pow ( img / 255 . 0 , correction ) return np . uint8 ( img * 255 ) intersect def intersect ( v1 , v2 ) View Source def intersect ( v1 , v2 ) : a1 , a2 = v1 b1 , b2 = v2 da = a2 - a1 db = b2 - b1 dp = a1 - b1 dap = perp ( da ) denom = np . dot ( dap , db ) . astype ( float ) num = np . dot ( dap , dp ) return ( num / denom ) * db + b1 open_file def open_file ( input_filename ) Given a filename, returns a numpy array View Source def open_file ( input_filename ) : \"\"\" Given a filename, returns a numpy array \"\"\" extension = os . path . splitext ( input_filename ) [ 1 ]. lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None perp def perp ( a ) View Source def perp ( a ) : b = np . empty_like ( a ) b [ 0 ] = - a [ 1 ] b [ 1 ] = a [ 0 ] return b Classes Cropper class Cropper ( width = 500 , height = 500 , face_percent = 50 , padding = None , fix_gamma = True , resize = True ) View Source class Cropper : \" \"\" Crops the largest detected face from images. This class uses the `CascadeClassifier` from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- * `width` : `int`, default=500 - The width of the resulting array. * `height` : `int`, default=`500` - The height of the resulting array. * `face_percent`: `int`, default=`50` - Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. * `fix_gamma`: `bool`, default=`True` - Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. * `resize`: `bool`, default=`True` - Resizes the image to the specified width and height, otherwise, returns the original image pixels. \"\" \" def __init__ ( self , width = 500 , height = 500 , face_percent = 50 , padding = None , fix_gamma = True , resize = True , ) : self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) self . aspect_ratio = width / height self . gamma = fix_gamma self . resize = resize # Face percent if face_percent > 100 or face_percent < 1 : fp_error = \"The face_percent argument must be between 1 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ) : \" \"\" Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- - `path_or_array` : {`str`, `np.ndarray`} * The filepath or numpy array of the image. Returns ------- - `image` : {`np.ndarray`, `None`} * A cropped numpy array if face detected, else None. \"\" \" if isinstance ( path_or_array , str ) : image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [ : 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h , ) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ] , pos [ 2 ] : pos [ 3 ]] # Resize if self . resize : image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition fix if self . gamma : image = check_underexposed ( image , gray ) return bgr_to_rbg ( image ) def _determine_safe_zoom ( self , imgh , imgw , x , y , w , h ) : \" \"\" Determines the safest zoom level with which to add margins around the detected face. Tries to honor `self.face_percent` when possible. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face Diagram: -------- i / j := zoom / 100 + h1 | h2 +---------|---------+ | MAR|GIN | | (x+w, y+h)| | +-----|-----+ | | | FA|CE | | | | | | | | \u251c\u2500\u2500i\u2500\u2500\u2524 | | | | cen|ter | | | | | | | | +-----|-----+ | | (x, y)| | | | | +---------|---------+ \u251c\u2500\u2500\u2500\u2500j\u2500\u2500\u2500\u2500\u2524 + \"\" \" # Find out what zoom factor to use given self.aspect_ratio corners = itertools . product (( x , x + w ), ( y , y + h )) center = np . array ( [ x + int ( w / 2 ), y + int ( h / 2 ) ] ) i = np . array ( [ ( 0 , 0 ), ( 0 , imgh ), ( imgw , imgh ), ( imgw , 0 ), ( 0 , 0 ) ] ) # image_corners image_sides = [ ( i [ n ] , i [ n + 1 ] ) for n in range ( 4 ) ] corner_ratios = [ self . face_percent ] # Hopefully we use this one for c in corners : corner_vector = np . array ( [ center , c ] ) a = distance ( * corner_vector ) intersects = list ( intersect ( corner_vector , side ) for side in image_sides ) for pt in intersects : if ( pt >= 0 ). all () and ( pt <= i [ 2 ] ). all () : # if intersect within image dist_to_pt = distance ( center , pt ) corner_ratios . append ( 100 * a / dist_to_pt ) return max ( corner_ratios ) def _crop_positions ( self , imgh , imgw , x , y , w , h , ) : \" \"\" Retuns the coordinates of the crop position centered around the detected face with extra margins. Tries to honor `self.face_percent` if possible, else uses the largest margins that comply with required aspect ratio given by `self.height` and `self.width`. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face \"\" \" zoom = self . _determine_safe_zoom ( imgh , imgw , x , y , w , h ) # Adjust output height based on percent if self . height >= self . width : height_crop = h * 100.0 / zoom width_crop = self . aspect_ratio * float ( height_crop ) else : width_crop = w * 100.0 / zoom height_crop = float ( width_crop ) / self . aspect_ratio # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = x - xpad h2 = x + w + xpad v1 = y - ypad v2 = y + h + ypad return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 ) ] Methods crop def crop ( self , path_or_array ) Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters: Name Type Description Default - path_or_array { str , np.ndarray } * The filepath or numpy array of the image. None Returns: Type Description { np.ndarray , None } * A cropped numpy array if face detected, else None. View Source def crop ( self , path_or_array ) : \" \"\" Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- - `path_or_array` : {`str`, `np.ndarray`} * The filepath or numpy array of the image. Returns ------- - `image` : {`np.ndarray`, `None`} * A cropped numpy array if face detected, else None. \"\" \" if isinstance ( path_or_array , str ) : image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [ : 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h , ) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ] , pos [ 2 ] : pos [ 3 ]] # Resize if self . resize : image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition fix if self . gamma : image = check_underexposed ( image , gray ) return bgr_to_rbg ( image ) ImageReadError class ImageReadError ( / , * args , ** kwargs ) View Source class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type.\"\"\" pass Ancestors (in MRO) builtins.BaseException Class variables args Methods with_traceback def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"Autocrop"},{"location":"reference/autocrop/autocrop/#module-autocropautocrop","text":"None None View Source import itertools import cv2 import numpy as np import os import sys from PIL import Image from .constants import ( MINFACE , GAMMA_THRES , GAMMA , CV2_FILETYPES , PILLOW_FILETYPES , CASCFILE , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type.\"\"\" pass def perp ( a ): b = np . empty_like ( a ) b [ 0 ] = - a [ 1 ] b [ 1 ] = a [ 0 ] return b def intersect ( v1 , v2 ): a1 , a2 = v1 b1 , b2 = v2 da = a2 - a1 db = b2 - b1 dp = a1 - b1 dap = perp ( da ) denom = np . dot ( dap , db ) . astype ( float ) num = np . dot ( dap , dp ) return ( num / denom ) * db + b1 def distance ( pt1 , pt2 ): \"\"\"Returns the euclidian distance in 2D between 2 pts.\"\"\" distance = np . linalg . norm ( pt2 - pt1 ) return distance def bgr_to_rbg ( img ): \"\"\"Given a BGR (cv2) numpy array, returns a RBG (standard) array.\"\"\" dimensions = len ( img . shape ) if dimensions == 2 : return img return img [ ... , :: - 1 ] def gamma ( img , correction ): \"\"\"Simple gamma correction to brighten faces\"\"\" img = cv2 . pow ( img / 255.0 , correction ) return np . uint8 ( img * 255 ) def check_underexposed ( image , gray ): \"\"\" Returns the (cropped) image with GAMMA applied if underexposition is detected. \"\"\" uexp = cv2 . calcHist ([ gray ], [ 0 ], None , [ 256 ], [ 0 , 256 ]) if sum ( uexp [ - 26 :]) < GAMMA_THRES * sum ( uexp ): image = gamma ( image , GAMMA ) return image def check_positive_scalar ( num ): \"\"\"Returns True if value if a positive scalar.\"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ): return int ( num ) raise ValueError ( \"A positive scalar is required\" ) def open_file ( input_filename ): \"\"\"Given a filename, returns a numpy array\"\"\" extension = os . path . splitext ( input_filename )[ 1 ] . lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None class Cropper : \"\"\" Crops the largest detected face from images. This class uses the `CascadeClassifier` from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- * `width` : `int`, default=500 - The width of the resulting array. * `height` : `int`, default=`500` - The height of the resulting array. * `face_percent`: `int`, default=`50` - Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. * `fix_gamma`: `bool`, default=`True` - Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. * `resize`: `bool`, default=`True` - Resizes the image to the specified width and height, otherwise, returns the original image pixels. \"\"\" def __init__ ( self , width = 500 , height = 500 , face_percent = 50 , padding = None , fix_gamma = True , resize = True , ): self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) self . aspect_ratio = width / height self . gamma = fix_gamma self . resize = resize # Face percent if face_percent > 100 or face_percent < 1 : fp_error = \"The face_percent argument must be between 1 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ): \"\"\" Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- - `path_or_array` : {`str`, `np.ndarray`} * The filepath or numpy array of the image. Returns ------- - `image` : {`np.ndarray`, `None`} * A cropped numpy array if face detected, else None. \"\"\" if isinstance ( path_or_array , str ): image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [: 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h , ) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ], pos [ 2 ] : pos [ 3 ]] # Resize if self . resize : image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition fix if self . gamma : image = check_underexposed ( image , gray ) return bgr_to_rbg ( image ) def _determine_safe_zoom ( self , imgh , imgw , x , y , w , h ): \"\"\" Determines the safest zoom level with which to add margins around the detected face. Tries to honor `self.face_percent` when possible. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face Diagram: -------- i / j := zoom / 100 + h1 | h2 +---------|---------+ | MAR|GIN | | (x+w, y+h)| | +-----|-----+ | | | FA|CE | | | | | | | | \u251c\u2500\u2500i\u2500\u2500\u2524 | | | | cen|ter | | | | | | | | +-----|-----+ | | (x, y)| | | | | +---------|---------+ \u251c\u2500\u2500\u2500\u2500j\u2500\u2500\u2500\u2500\u2524 + \"\"\" # Find out what zoom factor to use given self.aspect_ratio corners = itertools . product (( x , x + w ), ( y , y + h )) center = np . array ([ x + int ( w / 2 ), y + int ( h / 2 )]) i = np . array ( [( 0 , 0 ), ( 0 , imgh ), ( imgw , imgh ), ( imgw , 0 ), ( 0 , 0 )] ) # image_corners image_sides = [( i [ n ], i [ n + 1 ]) for n in range ( 4 )] corner_ratios = [ self . face_percent ] # Hopefully we use this one for c in corners : corner_vector = np . array ([ center , c ]) a = distance ( * corner_vector ) intersects = list ( intersect ( corner_vector , side ) for side in image_sides ) for pt in intersects : if ( pt >= 0 ) . all () and ( pt <= i [ 2 ]) . all (): # if intersect within image dist_to_pt = distance ( center , pt ) corner_ratios . append ( 100 * a / dist_to_pt ) return max ( corner_ratios ) def _crop_positions ( self , imgh , imgw , x , y , w , h , ): \"\"\" Retuns the coordinates of the crop position centered around the detected face with extra margins. Tries to honor `self.face_percent` if possible, else uses the largest margins that comply with required aspect ratio given by `self.height` and `self.width`. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face \"\"\" zoom = self . _determine_safe_zoom ( imgh , imgw , x , y , w , h ) # Adjust output height based on percent if self . height >= self . width : height_crop = h * 100.0 / zoom width_crop = self . aspect_ratio * float ( height_crop ) else : width_crop = w * 100.0 / zoom height_crop = float ( width_crop ) / self . aspect_ratio # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = x - xpad h2 = x + w + xpad v1 = y - ypad v2 = y + h + ypad return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 )]","title":"Module autocrop.autocrop"},{"location":"reference/autocrop/autocrop/#variables","text":"CASCFILE COMBINED_FILETYPES CV2_FILETYPES GAMMA GAMMA_THRES INPUT_FILETYPES MINFACE PILLOW_FILETYPES","title":"Variables"},{"location":"reference/autocrop/autocrop/#functions","text":"","title":"Functions"},{"location":"reference/autocrop/autocrop/#bgr_to_rbg","text":"def bgr_to_rbg ( img ) Given a BGR (cv2) numpy array, returns a RBG (standard) array. View Source def bgr_to_rbg ( img ) : \"\"\"Given a BGR (cv2) numpy array, returns a RBG (standard) array.\"\"\" dimensions = len ( img . shape ) if dimensions == 2 : return img return img [..., ::- 1 ]","title":"bgr_to_rbg"},{"location":"reference/autocrop/autocrop/#check_positive_scalar","text":"def check_positive_scalar ( num ) Returns True if value if a positive scalar. View Source def check_positive_scalar ( num ) : \"\"\" Returns True if value if a positive scalar. \"\"\" if num > 0 and not isinstance ( num , str ) and np . isscalar ( num ) : return int ( num ) raise ValueError ( \" A positive scalar is required \" )","title":"check_positive_scalar"},{"location":"reference/autocrop/autocrop/#check_underexposed","text":"def check_underexposed ( image , gray ) Returns the (cropped) image with GAMMA applied if underexposition is detected. View Source def check_underexposed ( image , gray ) : \"\"\" Returns the (cropped) image with GAMMA applied if underexposition is detected. \"\"\" uexp = cv2 . calcHist ( [ gray ] , [ 0 ] , None , [ 256 ] , [ 0, 256 ] ) if sum ( uexp [ -26: ] ) < GAMMA_THRES * sum ( uexp ) : image = gamma ( image , GAMMA ) return image","title":"check_underexposed"},{"location":"reference/autocrop/autocrop/#distance","text":"def distance ( pt1 , pt2 ) Returns the euclidian distance in 2D between 2 pts. View Source def distance ( pt1 , pt2 ) : \"\"\" Returns the euclidian distance in 2D between 2 pts. \"\"\" distance = np . linalg . norm ( pt2 - pt1 ) return distance","title":"distance"},{"location":"reference/autocrop/autocrop/#gamma","text":"def gamma ( img , correction ) Simple gamma correction to brighten faces View Source def gamma ( img , correction ) : \"\"\" Simple gamma correction to brighten faces \"\"\" img = cv2 . pow ( img / 255 . 0 , correction ) return np . uint8 ( img * 255 )","title":"gamma"},{"location":"reference/autocrop/autocrop/#intersect","text":"def intersect ( v1 , v2 ) View Source def intersect ( v1 , v2 ) : a1 , a2 = v1 b1 , b2 = v2 da = a2 - a1 db = b2 - b1 dp = a1 - b1 dap = perp ( da ) denom = np . dot ( dap , db ) . astype ( float ) num = np . dot ( dap , dp ) return ( num / denom ) * db + b1","title":"intersect"},{"location":"reference/autocrop/autocrop/#open_file","text":"def open_file ( input_filename ) Given a filename, returns a numpy array View Source def open_file ( input_filename ) : \"\"\" Given a filename, returns a numpy array \"\"\" extension = os . path . splitext ( input_filename ) [ 1 ]. lower () if extension in CV2_FILETYPES : # Try with cv2 return cv2 . imread ( input_filename ) if extension in PILLOW_FILETYPES : # Try with PIL with Image . open ( input_filename ) as img_orig : return np . asarray ( img_orig ) return None","title":"open_file"},{"location":"reference/autocrop/autocrop/#perp","text":"def perp ( a ) View Source def perp ( a ) : b = np . empty_like ( a ) b [ 0 ] = - a [ 1 ] b [ 1 ] = a [ 0 ] return b","title":"perp"},{"location":"reference/autocrop/autocrop/#classes","text":"","title":"Classes"},{"location":"reference/autocrop/autocrop/#cropper","text":"class Cropper ( width = 500 , height = 500 , face_percent = 50 , padding = None , fix_gamma = True , resize = True ) View Source class Cropper : \" \"\" Crops the largest detected face from images. This class uses the `CascadeClassifier` from OpenCV to perform the `crop` by taking in either a filepath or Numpy array, and returning a Numpy array. By default, also provides a slight gamma fix to lighten the face in its new context. Parameters: ----------- * `width` : `int`, default=500 - The width of the resulting array. * `height` : `int`, default=`500` - The height of the resulting array. * `face_percent`: `int`, default=`50` - Aka zoom factor. Percent of the overall size of the cropped image containing the detected coordinates. * `fix_gamma`: `bool`, default=`True` - Cropped faces are often underexposed when taken out of their context. If under a threshold, sets the gamma to 0.9. * `resize`: `bool`, default=`True` - Resizes the image to the specified width and height, otherwise, returns the original image pixels. \"\" \" def __init__ ( self , width = 500 , height = 500 , face_percent = 50 , padding = None , fix_gamma = True , resize = True , ) : self . height = check_positive_scalar ( height ) self . width = check_positive_scalar ( width ) self . aspect_ratio = width / height self . gamma = fix_gamma self . resize = resize # Face percent if face_percent > 100 or face_percent < 1 : fp_error = \"The face_percent argument must be between 1 and 100\" raise ValueError ( fp_error ) self . face_percent = check_positive_scalar ( face_percent ) # XML Resource directory = os . path . dirname ( sys . modules [ \"autocrop\" ] . __file__ ) self . casc_path = os . path . join ( directory , CASCFILE ) def crop ( self , path_or_array ) : \" \"\" Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- - `path_or_array` : {`str`, `np.ndarray`} * The filepath or numpy array of the image. Returns ------- - `image` : {`np.ndarray`, `None`} * A cropped numpy array if face detected, else None. \"\" \" if isinstance ( path_or_array , str ) : image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [ : 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h , ) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ] , pos [ 2 ] : pos [ 3 ]] # Resize if self . resize : image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition fix if self . gamma : image = check_underexposed ( image , gray ) return bgr_to_rbg ( image ) def _determine_safe_zoom ( self , imgh , imgw , x , y , w , h ) : \" \"\" Determines the safest zoom level with which to add margins around the detected face. Tries to honor `self.face_percent` when possible. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face Diagram: -------- i / j := zoom / 100 + h1 | h2 +---------|---------+ | MAR|GIN | | (x+w, y+h)| | +-----|-----+ | | | FA|CE | | | | | | | | \u251c\u2500\u2500i\u2500\u2500\u2524 | | | | cen|ter | | | | | | | | +-----|-----+ | | (x, y)| | | | | +---------|---------+ \u251c\u2500\u2500\u2500\u2500j\u2500\u2500\u2500\u2500\u2524 + \"\" \" # Find out what zoom factor to use given self.aspect_ratio corners = itertools . product (( x , x + w ), ( y , y + h )) center = np . array ( [ x + int ( w / 2 ), y + int ( h / 2 ) ] ) i = np . array ( [ ( 0 , 0 ), ( 0 , imgh ), ( imgw , imgh ), ( imgw , 0 ), ( 0 , 0 ) ] ) # image_corners image_sides = [ ( i [ n ] , i [ n + 1 ] ) for n in range ( 4 ) ] corner_ratios = [ self . face_percent ] # Hopefully we use this one for c in corners : corner_vector = np . array ( [ center , c ] ) a = distance ( * corner_vector ) intersects = list ( intersect ( corner_vector , side ) for side in image_sides ) for pt in intersects : if ( pt >= 0 ). all () and ( pt <= i [ 2 ] ). all () : # if intersect within image dist_to_pt = distance ( center , pt ) corner_ratios . append ( 100 * a / dist_to_pt ) return max ( corner_ratios ) def _crop_positions ( self , imgh , imgw , x , y , w , h , ) : \" \"\" Retuns the coordinates of the crop position centered around the detected face with extra margins. Tries to honor `self.face_percent` if possible, else uses the largest margins that comply with required aspect ratio given by `self.height` and `self.width`. Parameters: ----------- imgh: int Height (px) of the image to be cropped imgw: int Width (px) of the image to be cropped x: int Leftmost coordinates of the detected face y: int Bottom-most coordinates of the detected face w: int Width of the detected face h: int Height of the detected face \"\" \" zoom = self . _determine_safe_zoom ( imgh , imgw , x , y , w , h ) # Adjust output height based on percent if self . height >= self . width : height_crop = h * 100.0 / zoom width_crop = self . aspect_ratio * float ( height_crop ) else : width_crop = w * 100.0 / zoom height_crop = float ( width_crop ) / self . aspect_ratio # Calculate padding by centering face xpad = ( width_crop - w ) / 2 ypad = ( height_crop - h ) / 2 # Calc. positions of crop h1 = x - xpad h2 = x + w + xpad v1 = y - ypad v2 = y + h + ypad return [ int ( v1 ), int ( v2 ), int ( h1 ), int ( h2 ) ]","title":"Cropper"},{"location":"reference/autocrop/autocrop/#methods","text":"","title":"Methods"},{"location":"reference/autocrop/autocrop/#crop","text":"def crop ( self , path_or_array ) Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters: Name Type Description Default - path_or_array { str , np.ndarray } * The filepath or numpy array of the image. None Returns: Type Description { np.ndarray , None } * A cropped numpy array if face detected, else None. View Source def crop ( self , path_or_array ) : \" \"\" Given a file path or np.ndarray image with a face, returns cropped np.ndarray around the largest detected face. Parameters ---------- - `path_or_array` : {`str`, `np.ndarray`} * The filepath or numpy array of the image. Returns ------- - `image` : {`np.ndarray`, `None`} * A cropped numpy array if face detected, else None. \"\" \" if isinstance ( path_or_array , str ) : image = open_file ( path_or_array ) else : image = path_or_array # Some grayscale color profiles can throw errors, catch them try : gray = cv2 . cvtColor ( image , cv2 . COLOR_BGR2GRAY ) except cv2 . error : gray = image # Scale the image try : img_height , img_width = image . shape [ : 2 ] except AttributeError : raise ImageReadError minface = int ( np . sqrt ( img_height ** 2 + img_width ** 2 ) / MINFACE ) # Create the haar cascade face_cascade = cv2 . CascadeClassifier ( self . casc_path ) # ====== Detect faces in the image ====== faces = face_cascade . detectMultiScale ( gray , scaleFactor = 1.1 , minNeighbors = 5 , minSize = ( minface , minface ), flags = cv2 . CASCADE_FIND_BIGGEST_OBJECT | cv2 . CASCADE_DO_ROUGH_SEARCH , ) # Handle no faces if len ( faces ) == 0 : return None # Make padding from biggest face found x , y , w , h = faces [ - 1 ] pos = self . _crop_positions ( img_height , img_width , x , y , w , h , ) # ====== Actual cropping ====== image = image [ pos [ 0 ] : pos [ 1 ] , pos [ 2 ] : pos [ 3 ]] # Resize if self . resize : image = cv2 . resize ( image , ( self . width , self . height ), interpolation = cv2 . INTER_AREA ) # Underexposition fix if self . gamma : image = check_underexposed ( image , gray ) return bgr_to_rbg ( image )","title":"crop"},{"location":"reference/autocrop/autocrop/#imagereaderror","text":"class ImageReadError ( / , * args , ** kwargs ) View Source class ImageReadError ( BaseException ): \"\"\"Custom exception to catch an OpenCV failure type.\"\"\" pass","title":"ImageReadError"},{"location":"reference/autocrop/autocrop/#ancestors-in-mro","text":"builtins.BaseException","title":"Ancestors (in MRO)"},{"location":"reference/autocrop/autocrop/#class-variables","text":"args","title":"Class variables"},{"location":"reference/autocrop/autocrop/#methods_1","text":"","title":"Methods"},{"location":"reference/autocrop/autocrop/#with_traceback","text":"def with_traceback ( ... ) Exception.with_traceback(tb) -- set self. traceback to tb and return self.","title":"with_traceback"},{"location":"reference/autocrop/cli/","text":"Module autocrop.cli None None View Source import argparse import os import shutil import sys from typing import Optional from PIL import Image from .__version__ import __version__ from .autocrop import Cropper , ImageReadError from .constants import ( QUESTION_OVERWRITE , CV2_FILETYPES , PILLOW_FILETYPES , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] def output ( input_filename , output_filename , image ): \"\"\" Move the input file to the output location and write over it with the cropped image data. \"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . copy ( input_filename , output_filename ) # Encode the image as an in-memory PNG img_new = Image . fromarray ( image ) # Write the new image (converting the format to match the output # filename if necessary) img_new . save ( output_filename ) def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . copy ( input_filename , reject_filename ) def main ( input_d : str , output_d : str , reject_d : str , extension : Optional [ str ] = None , fheight : int = 500 , fwidth : int = 500 , facePercent : int = 50 , resize : bool = True , ) -> None : \"\"\" Crops folder of images to the desired height and width if a face is found. If `input_d == output_d` or `output_d is None`, overwrites all files where the biggest face was found. Parameters: ----------- - `input_d`: `str` * Directory to crop images from. - `output_d`: `str` * Directory where cropped images are placed. - `reject_d`: `str` * Directory where images that cannot be cropped are placed. - `fheight`: `int`, default=`500` * Height (px) to which to crop the image. - `fwidth`: `int`, default=`500` * Width (px) to which to crop the image. - `facePercent`: `int`, default=`50` * Percentage of face from height. - `extension` : `str` * Image extension to save at output. - `resize`: `bool`, default=`True` * If `False`, don't resize the image, but use the original size. Side Effects: ------------- - Creates image files in output directory. \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop cropper = Cropper ( width = fwidth , height = fheight , face_percent = facePercent , resize = resize ) for input_filename in input_files : basename = os . path . basename ( input_filename ) if extension : basename_noext = os . path . splitext ( basename )[ 0 ] output_filename = os . path . join ( output_d , basename_noext + \".\" + extension ) else : output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {} \" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {} \" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {} \" . format ( output_filename )) output_count += 1 # Stop and print status print ( f \" { input_count } : Input files, { output_count } : Faces Cropped, { reject_count } \" ) def input_path ( p ): \"\"\"Returns path, only if input is a valid directory.\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = { os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )} if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p def output_path ( p ): \"\"\" Returns path, if input is a valid directory name. If directory doesn't exist, creates it. \"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1e5 : return i else : raise argparse . ArgumentTypeError ( error ) def compat_input ( s = \"\" ): # pragma: no cover \"\"\"Compatibility function to permit testing for Python 2 and 3.\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input() renamed to input() in Py3 return input ( s ) # lgtm[py/use-of-input] def confirmation ( question ): \"\"\"Ask a yes/no question via standard input and return the answer.\"\"\" yes_list = [ \"yes\" , \"y\" ] no_list = [ \"no\" , \"n\" ] default_str = \"[Y]/n\" prompt_str = \" {} {} \" . format ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) def chk_extension ( extension ): \"\"\"Check if the extension passed is valid or not.\"\"\" error = \"Invalid image extension\" extension = str ( extension ) . lower () if not extension . startswith ( \".\" ): extension = f \". { extension } \" if extension in COMBINED_FILETYPES : return extension . lower () . replace ( \".\" , \"\" ) else : raise argparse . ArgumentTypeError ( error ) def parse_args ( args ): \"\"\"Helper function. Parses the arguments given to the CLI.\"\"\" help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"extension\" : \"Enter the image extension which to save at output\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"no_resize\" : \"\"\"Do not resize images to the specified width and height, but instead use the original image's pixels.\"\"\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s version {} \" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"-n\" , \"--no-resize\" , action = \"store_true\" , help = help_d [ \"no_resize\" ], ) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ]) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ]) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) parser . add_argument ( \"-e\" , \"--extension\" , type = chk_extension , default = None , help = help_d [ \"extension\" ] ) return parser . parse_args () def command_line_interface (): \"\"\" AUTOCROP -------- Crops faces from batches of images. \"\"\" args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) resize = not args . no_resize main ( args . input , args . output , args . reject , args . extension , args . height , args . width , args . facePercent , resize , ) Variables COMBINED_FILETYPES CV2_FILETYPES INPUT_FILETYPES PILLOW_FILETYPES QUESTION_OVERWRITE Functions chk_extension def chk_extension ( extension ) Check if the extension passed is valid or not. View Source def chk_extension ( extension ) : \"\"\" Check if the extension passed is valid or not. \"\"\" error = \" Invalid image extension \" extension = str ( extension ) . lower () if not extension . startswith ( \" . \" ) : extension = f \" .{extension} \" if extension in COMBINED_FILETYPES : return extension . lower () . replace ( \" . \" , \"\" ) else : raise argparse . ArgumentTypeError ( error ) command_line_interface def command_line_interface ( ) AUTOCROP Crops faces from batches of images. View Source def command_line_interface () : \"\"\" AUTOCROP -------- Crops faces from batches of images . \"\"\" args = parse_args ( sys . argv [ 1 :] ) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ) : sys . exit () if args . input == args . output : args . output = None print ( \" Processing images in folder: \" , args . input ) resize = not args . no_resize main ( args . input , args . output , args . reject , args . extension , args . height , args . width , args . facePercent , resize , ) compat_input def compat_input ( s = '' ) Compatibility function to permit testing for Python 2 and 3. View Source def compat_input ( s = \"\" ) : # pragma : no cover \"\"\" Compatibility function to permit testing for Python 2 and 3. \"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input () renamed to input () in Py3 return input ( s ) # lgtm [ py / use - of - input ] confirmation def confirmation ( question ) Ask a yes/no question via standard input and return the answer. View Source def confirmation ( question ) : \"\"\"Ask a yes/no question via standard input and return the answer.\"\"\" yes_list = [ \"yes\", \"y\" ] no_list = [ \"no\", \"n\" ] default_str = \"[Y]/n\" prompt_str = \"{} {} \" . format ( question , default_str ) while True : choice = compat_input ( prompt_str ). lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) input_path def input_path ( p ) Returns path, only if input is a valid directory. View Source def input_path ( p ) : \"\"\" Returns path, only if input is a valid directory. \"\"\" no_folder = \" Input folder does not exist \" no_images = \" Input folder does not contain any image files \" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : raise argparse . ArgumentTypeError ( no_folder ) filetypes = { os . path . splitext ( f ) [ - 1 ] for f in os . listdir ( p ) } if not any ( t in INPUT_FILETYPES for t in filetypes ) : raise argparse . ArgumentTypeError ( no_images ) else : return p main def main ( input_d : str , output_d : str , reject_d : str , extension : Optional [ str ] = None , fheight : int = 500 , fwidth : int = 500 , facePercent : int = 50 , resize : bool = True ) -> None Crops folder of images to the desired height and width if a face is found. If input_d == output_d or output_d is None , overwrites all files where the biggest face was found. Parameters: input_d : str Directory to crop images from. output_d : str Directory where cropped images are placed. reject_d : str Directory where images that cannot be cropped are placed. fheight : int , default= 500 Height (px) to which to crop the image. fwidth : int , default= 500 Width (px) to which to crop the image. facePercent : int , default= 50 Percentage of face from height. extension : str Image extension to save at output. resize : bool , default= True If False , don't resize the image, but use the original size. Side Effects: Creates image files in output directory. View Source def main ( input_d : str , output_d : str , reject_d : str , extension : Optional [ str ] = None , fheight : int = 500 , fwidth : int = 500 , facePercent : int = 50 , resize : bool = True , ) -> None : \" \"\" Crops folder of images to the desired height and width if a face is found. If `input_d == output_d` or `output_d is None`, overwrites all files where the biggest face was found. Parameters: ----------- - `input_d`: `str` * Directory to crop images from. - `output_d`: `str` * Directory where cropped images are placed. - `reject_d`: `str` * Directory where images that cannot be cropped are placed. - `fheight`: `int`, default=`500` * Height (px) to which to crop the image. - `fwidth`: `int`, default=`500` * Width (px) to which to crop the image. - `facePercent`: `int`, default=`50` * Percentage of face from height. - `extension` : `str` * Image extension to save at output. - `resize`: `bool`, default=`True` * If `False`, don't resize the image, but use the original size. Side Effects: ------------- - Creates image files in output directory. \"\" \" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop cropper = Cropper ( width = fwidth , height = fheight , face_percent = facePercent , resize = resize ) for input_filename in input_files : basename = os . path . basename ( input_filename ) if extension : basename_noext = os . path . splitext ( basename ) [ 0 ] output_filename = os . path . join ( output_d , basename_noext + \".\" + extension ) else : output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )) : reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( f \"{input_count} : Input files, {output_count} : Faces Cropped, {reject_count}\" ) output def output ( input_filename , output_filename , image ) Move the input file to the output location and write over it with the cropped image data. View Source def output ( input_filename , output_filename , image ) : \"\"\" Move the input file to the output location and write over it with the cropped image data . \"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . copy ( input_filename , output_filename ) # Encode the image as an in - memory PNG img_new = Image . fromarray ( image ) # Write the new image ( converting the format to match the output # filename if necessary ) img_new . save ( output_filename ) output_path def output_path ( p ) Returns path, if input is a valid directory name. If directory doesn't exist, creates it. View Source def output_path ( p ) : \"\"\" Returns path , if input is a valid directory name . If directory doesn ' t exist, creates it. \"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : os . makedirs ( p ) return p parse_args def parse_args ( args ) Helper function. Parses the arguments given to the CLI. View Source def parse_args ( args ) : \"\"\" Helper function. Parses the arguments given to the CLI. \"\"\" help_d = { \" desc \" : \" Automatically crops faces from batches of pictures \" , \" input \" : \"\"\" Folder where images to crop are located. Default: current working directory \"\"\" , \" output \" : \"\"\" Folder where cropped images will be moved to. Default : current working directory , meaning images are cropped in place . \"\"\" , \" reject \" : \"\"\" Folder where images that could not be cropped will be moved to . Default : current working directory , meaning images that are not cropped will be left in place . \"\"\" , \" extension \" : \" Enter the image extension which to save at output \" , \" width \" : \" Width of cropped files in px. Default=500 \" , \" height \" : \" Height of cropped files in px. Default=500 \" , \" y \" : \" Bypass any confirmation prompts \" , \" facePercent \" : \" Percentage of face to image height \" , \" no_resize \" : \"\"\" Do not resize images to the specified width and height, but instead use the original image ' s pixels.\"\"\", } parser = argparse . ArgumentParser ( description = help_d [ \" desc \" ] ) parser . add_argument ( \" -v \" , \" --version \" , action = \" version \" , version = \" %(prog)s version {} \" . format ( __version__ ) , ) parser . add_argument ( \" --no-confirm \" , action = \" store_true \" , help = help_d [ \" y \" ] ) parser . add_argument ( \" -n \" , \" --no-resize \" , action = \" store_true \" , help = help_d [ \" no_resize \" ], ) parser . add_argument ( \" -i \" , \" --input \" , default = \" . \" , type = input_path , help = help_d [ \" input \" ] ) parser . add_argument ( \" -o \" , \" --output \" , \" -p \" , \" --path \" , type = output_path , default = None , help = help_d [ \" output \" ], ) parser . add_argument ( \" -r \" , \" --reject \" , type = output_path , default = None , help = help_d [ \" reject \" ] ) parser . add_argument ( \" -w \" , \" --width \" , type = size , default = 500 , help = help_d [ \" width \" ] ) parser . add_argument ( \" -H \" , \" --height \" , type = size , default = 500 , help = help_d [ \" height \" ] ) parser . add_argument ( \" --facePercent \" , type = size , default = 50 , help = help_d [ \" facePercent \" ] ) parser . add_argument ( \" -e \" , \" --extension \" , type = chk_extension , default = None , help = help_d [ \" extension \" ] ) return parser . parse_args () reject def reject ( input_filename , reject_filename ) Move the input file to the reject location. View Source def reject ( input_filename , reject_filename ) : \"\"\" Move the input file to the reject location. \"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . copy ( input_filename , reject_filename ) size def size ( i ) Returns valid only if input is a positive integer under 1e5 View Source def size ( i ) : \"\"\" Returns valid only if input is a positive integer under 1e5 \"\"\" error = \" Invalid pixel size \" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1 e5 : return i else : raise argparse . ArgumentTypeError ( error )","title":"CLI"},{"location":"reference/autocrop/cli/#module-autocropcli","text":"None None View Source import argparse import os import shutil import sys from typing import Optional from PIL import Image from .__version__ import __version__ from .autocrop import Cropper , ImageReadError from .constants import ( QUESTION_OVERWRITE , CV2_FILETYPES , PILLOW_FILETYPES , ) COMBINED_FILETYPES = CV2_FILETYPES + PILLOW_FILETYPES INPUT_FILETYPES = COMBINED_FILETYPES + [ s . upper () for s in COMBINED_FILETYPES ] def output ( input_filename , output_filename , image ): \"\"\" Move the input file to the output location and write over it with the cropped image data. \"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . copy ( input_filename , output_filename ) # Encode the image as an in-memory PNG img_new = Image . fromarray ( image ) # Write the new image (converting the format to match the output # filename if necessary) img_new . save ( output_filename ) def reject ( input_filename , reject_filename ): \"\"\"Move the input file to the reject location.\"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . copy ( input_filename , reject_filename ) def main ( input_d : str , output_d : str , reject_d : str , extension : Optional [ str ] = None , fheight : int = 500 , fwidth : int = 500 , facePercent : int = 50 , resize : bool = True , ) -> None : \"\"\" Crops folder of images to the desired height and width if a face is found. If `input_d == output_d` or `output_d is None`, overwrites all files where the biggest face was found. Parameters: ----------- - `input_d`: `str` * Directory to crop images from. - `output_d`: `str` * Directory where cropped images are placed. - `reject_d`: `str` * Directory where images that cannot be cropped are placed. - `fheight`: `int`, default=`500` * Height (px) to which to crop the image. - `fwidth`: `int`, default=`500` * Width (px) to which to crop the image. - `facePercent`: `int`, default=`50` * Percentage of face from height. - `extension` : `str` * Image extension to save at output. - `resize`: `bool`, default=`True` * If `False`, don't resize the image, but use the original size. Side Effects: ------------- - Creates image files in output directory. \"\"\" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop cropper = Cropper ( width = fwidth , height = fheight , face_percent = facePercent , resize = resize ) for input_filename in input_files : basename = os . path . basename ( input_filename ) if extension : basename_noext = os . path . splitext ( basename )[ 0 ] output_filename = os . path . join ( output_d , basename_noext + \".\" + extension ) else : output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {} \" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )): reject ( input_filename , reject_filename ) print ( \"No face detected: {} \" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {} \" . format ( output_filename )) output_count += 1 # Stop and print status print ( f \" { input_count } : Input files, { output_count } : Faces Cropped, { reject_count } \" ) def input_path ( p ): \"\"\"Returns path, only if input is a valid directory.\"\"\" no_folder = \"Input folder does not exist\" no_images = \"Input folder does not contain any image files\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): raise argparse . ArgumentTypeError ( no_folder ) filetypes = { os . path . splitext ( f )[ - 1 ] for f in os . listdir ( p )} if not any ( t in INPUT_FILETYPES for t in filetypes ): raise argparse . ArgumentTypeError ( no_images ) else : return p def output_path ( p ): \"\"\" Returns path, if input is a valid directory name. If directory doesn't exist, creates it. \"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ): os . makedirs ( p ) return p def size ( i ): \"\"\"Returns valid only if input is a positive integer under 1e5\"\"\" error = \"Invalid pixel size\" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1e5 : return i else : raise argparse . ArgumentTypeError ( error ) def compat_input ( s = \"\" ): # pragma: no cover \"\"\"Compatibility function to permit testing for Python 2 and 3.\"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input() renamed to input() in Py3 return input ( s ) # lgtm[py/use-of-input] def confirmation ( question ): \"\"\"Ask a yes/no question via standard input and return the answer.\"\"\" yes_list = [ \"yes\" , \"y\" ] no_list = [ \"no\" , \"n\" ] default_str = \"[Y]/n\" prompt_str = \" {} {} \" . format ( question , default_str ) while True : choice = compat_input ( prompt_str ) . lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str ) def chk_extension ( extension ): \"\"\"Check if the extension passed is valid or not.\"\"\" error = \"Invalid image extension\" extension = str ( extension ) . lower () if not extension . startswith ( \".\" ): extension = f \". { extension } \" if extension in COMBINED_FILETYPES : return extension . lower () . replace ( \".\" , \"\" ) else : raise argparse . ArgumentTypeError ( error ) def parse_args ( args ): \"\"\"Helper function. Parses the arguments given to the CLI.\"\"\" help_d = { \"desc\" : \"Automatically crops faces from batches of pictures\" , \"input\" : \"\"\"Folder where images to crop are located. Default: current working directory\"\"\" , \"output\" : \"\"\"Folder where cropped images will be moved to. Default: current working directory, meaning images are cropped in place.\"\"\" , \"reject\" : \"\"\"Folder where images that could not be cropped will be moved to. Default: current working directory, meaning images that are not cropped will be left in place.\"\"\" , \"extension\" : \"Enter the image extension which to save at output\" , \"width\" : \"Width of cropped files in px. Default=500\" , \"height\" : \"Height of cropped files in px. Default=500\" , \"y\" : \"Bypass any confirmation prompts\" , \"facePercent\" : \"Percentage of face to image height\" , \"no_resize\" : \"\"\"Do not resize images to the specified width and height, but instead use the original image's pixels.\"\"\" , } parser = argparse . ArgumentParser ( description = help_d [ \"desc\" ]) parser . add_argument ( \"-v\" , \"--version\" , action = \"version\" , version = \" %(prog)s version {} \" . format ( __version__ ), ) parser . add_argument ( \"--no-confirm\" , action = \"store_true\" , help = help_d [ \"y\" ]) parser . add_argument ( \"-n\" , \"--no-resize\" , action = \"store_true\" , help = help_d [ \"no_resize\" ], ) parser . add_argument ( \"-i\" , \"--input\" , default = \".\" , type = input_path , help = help_d [ \"input\" ] ) parser . add_argument ( \"-o\" , \"--output\" , \"-p\" , \"--path\" , type = output_path , default = None , help = help_d [ \"output\" ], ) parser . add_argument ( \"-r\" , \"--reject\" , type = output_path , default = None , help = help_d [ \"reject\" ] ) parser . add_argument ( \"-w\" , \"--width\" , type = size , default = 500 , help = help_d [ \"width\" ]) parser . add_argument ( \"-H\" , \"--height\" , type = size , default = 500 , help = help_d [ \"height\" ]) parser . add_argument ( \"--facePercent\" , type = size , default = 50 , help = help_d [ \"facePercent\" ] ) parser . add_argument ( \"-e\" , \"--extension\" , type = chk_extension , default = None , help = help_d [ \"extension\" ] ) return parser . parse_args () def command_line_interface (): \"\"\" AUTOCROP -------- Crops faces from batches of images. \"\"\" args = parse_args ( sys . argv [ 1 :]) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ): sys . exit () if args . input == args . output : args . output = None print ( \"Processing images in folder:\" , args . input ) resize = not args . no_resize main ( args . input , args . output , args . reject , args . extension , args . height , args . width , args . facePercent , resize , )","title":"Module autocrop.cli"},{"location":"reference/autocrop/cli/#variables","text":"COMBINED_FILETYPES CV2_FILETYPES INPUT_FILETYPES PILLOW_FILETYPES QUESTION_OVERWRITE","title":"Variables"},{"location":"reference/autocrop/cli/#functions","text":"","title":"Functions"},{"location":"reference/autocrop/cli/#chk_extension","text":"def chk_extension ( extension ) Check if the extension passed is valid or not. View Source def chk_extension ( extension ) : \"\"\" Check if the extension passed is valid or not. \"\"\" error = \" Invalid image extension \" extension = str ( extension ) . lower () if not extension . startswith ( \" . \" ) : extension = f \" .{extension} \" if extension in COMBINED_FILETYPES : return extension . lower () . replace ( \" . \" , \"\" ) else : raise argparse . ArgumentTypeError ( error )","title":"chk_extension"},{"location":"reference/autocrop/cli/#command_line_interface","text":"def command_line_interface ( ) AUTOCROP Crops faces from batches of images. View Source def command_line_interface () : \"\"\" AUTOCROP -------- Crops faces from batches of images . \"\"\" args = parse_args ( sys . argv [ 1 :] ) if not args . no_confirm : if args . output is None or args . input == args . output : if not confirmation ( QUESTION_OVERWRITE ) : sys . exit () if args . input == args . output : args . output = None print ( \" Processing images in folder: \" , args . input ) resize = not args . no_resize main ( args . input , args . output , args . reject , args . extension , args . height , args . width , args . facePercent , resize , )","title":"command_line_interface"},{"location":"reference/autocrop/cli/#compat_input","text":"def compat_input ( s = '' ) Compatibility function to permit testing for Python 2 and 3. View Source def compat_input ( s = \"\" ) : # pragma : no cover \"\"\" Compatibility function to permit testing for Python 2 and 3. \"\"\" try : return raw_input ( s ) except NameError : # Py2 raw_input () renamed to input () in Py3 return input ( s ) # lgtm [ py / use - of - input ]","title":"compat_input"},{"location":"reference/autocrop/cli/#confirmation","text":"def confirmation ( question ) Ask a yes/no question via standard input and return the answer. View Source def confirmation ( question ) : \"\"\"Ask a yes/no question via standard input and return the answer.\"\"\" yes_list = [ \"yes\", \"y\" ] no_list = [ \"no\", \"n\" ] default_str = \"[Y]/n\" prompt_str = \"{} {} \" . format ( question , default_str ) while True : choice = compat_input ( prompt_str ). lower () if not choice : return default_str if choice in yes_list : return True if choice in no_list : return False notification_str = \"Please respond with 'y' or 'n'\" print ( notification_str )","title":"confirmation"},{"location":"reference/autocrop/cli/#input_path","text":"def input_path ( p ) Returns path, only if input is a valid directory. View Source def input_path ( p ) : \"\"\" Returns path, only if input is a valid directory. \"\"\" no_folder = \" Input folder does not exist \" no_images = \" Input folder does not contain any image files \" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : raise argparse . ArgumentTypeError ( no_folder ) filetypes = { os . path . splitext ( f ) [ - 1 ] for f in os . listdir ( p ) } if not any ( t in INPUT_FILETYPES for t in filetypes ) : raise argparse . ArgumentTypeError ( no_images ) else : return p","title":"input_path"},{"location":"reference/autocrop/cli/#main","text":"def main ( input_d : str , output_d : str , reject_d : str , extension : Optional [ str ] = None , fheight : int = 500 , fwidth : int = 500 , facePercent : int = 50 , resize : bool = True ) -> None Crops folder of images to the desired height and width if a face is found. If input_d == output_d or output_d is None , overwrites all files where the biggest face was found.","title":"main"},{"location":"reference/autocrop/cli/#parameters","text":"input_d : str Directory to crop images from. output_d : str Directory where cropped images are placed. reject_d : str Directory where images that cannot be cropped are placed. fheight : int , default= 500 Height (px) to which to crop the image. fwidth : int , default= 500 Width (px) to which to crop the image. facePercent : int , default= 50 Percentage of face from height. extension : str Image extension to save at output. resize : bool , default= True If False , don't resize the image, but use the original size.","title":"Parameters:"},{"location":"reference/autocrop/cli/#side-effects","text":"Creates image files in output directory. View Source def main ( input_d : str , output_d : str , reject_d : str , extension : Optional [ str ] = None , fheight : int = 500 , fwidth : int = 500 , facePercent : int = 50 , resize : bool = True , ) -> None : \" \"\" Crops folder of images to the desired height and width if a face is found. If `input_d == output_d` or `output_d is None`, overwrites all files where the biggest face was found. Parameters: ----------- - `input_d`: `str` * Directory to crop images from. - `output_d`: `str` * Directory where cropped images are placed. - `reject_d`: `str` * Directory where images that cannot be cropped are placed. - `fheight`: `int`, default=`500` * Height (px) to which to crop the image. - `fwidth`: `int`, default=`500` * Width (px) to which to crop the image. - `facePercent`: `int`, default=`50` * Percentage of face from height. - `extension` : `str` * Image extension to save at output. - `resize`: `bool`, default=`True` * If `False`, don't resize the image, but use the original size. Side Effects: ------------- - Creates image files in output directory. \"\" \" reject_count = 0 output_count = 0 input_files = [ os . path . join ( input_d , f ) for f in os . listdir ( input_d ) if any ( f . endswith ( t ) for t in INPUT_FILETYPES ) ] if output_d is None : output_d = input_d if reject_d is None and output_d is None : reject_d = input_d if reject_d is None : reject_d = output_d # Guard against calling the function directly input_count = len ( input_files ) assert input_count > 0 # Main loop cropper = Cropper ( width = fwidth , height = fheight , face_percent = facePercent , resize = resize ) for input_filename in input_files : basename = os . path . basename ( input_filename ) if extension : basename_noext = os . path . splitext ( basename ) [ 0 ] output_filename = os . path . join ( output_d , basename_noext + \".\" + extension ) else : output_filename = os . path . join ( output_d , basename ) reject_filename = os . path . join ( reject_d , basename ) image = None # Attempt the crop try : image = cropper . crop ( input_filename ) except ImageReadError : print ( \"Read error: {}\" . format ( input_filename )) continue # Did the crop produce an invalid image? if isinstance ( image , type ( None )) : reject ( input_filename , reject_filename ) print ( \"No face detected: {}\" . format ( reject_filename )) reject_count += 1 else : output ( input_filename , output_filename , image ) print ( \"Face detected: {}\" . format ( output_filename )) output_count += 1 # Stop and print status print ( f \"{input_count} : Input files, {output_count} : Faces Cropped, {reject_count}\" )","title":"Side Effects:"},{"location":"reference/autocrop/cli/#output","text":"def output ( input_filename , output_filename , image ) Move the input file to the output location and write over it with the cropped image data. View Source def output ( input_filename , output_filename , image ) : \"\"\" Move the input file to the output location and write over it with the cropped image data . \"\"\" if input_filename != output_filename : # Move the file to the output directory shutil . copy ( input_filename , output_filename ) # Encode the image as an in - memory PNG img_new = Image . fromarray ( image ) # Write the new image ( converting the format to match the output # filename if necessary ) img_new . save ( output_filename )","title":"output"},{"location":"reference/autocrop/cli/#output_path","text":"def output_path ( p ) Returns path, if input is a valid directory name. If directory doesn't exist, creates it. View Source def output_path ( p ) : \"\"\" Returns path , if input is a valid directory name . If directory doesn ' t exist, creates it. \"\"\" p = os . path . abspath ( p ) if not os . path . isdir ( p ) : os . makedirs ( p ) return p","title":"output_path"},{"location":"reference/autocrop/cli/#parse_args","text":"def parse_args ( args ) Helper function. Parses the arguments given to the CLI. View Source def parse_args ( args ) : \"\"\" Helper function. Parses the arguments given to the CLI. \"\"\" help_d = { \" desc \" : \" Automatically crops faces from batches of pictures \" , \" input \" : \"\"\" Folder where images to crop are located. Default: current working directory \"\"\" , \" output \" : \"\"\" Folder where cropped images will be moved to. Default : current working directory , meaning images are cropped in place . \"\"\" , \" reject \" : \"\"\" Folder where images that could not be cropped will be moved to . Default : current working directory , meaning images that are not cropped will be left in place . \"\"\" , \" extension \" : \" Enter the image extension which to save at output \" , \" width \" : \" Width of cropped files in px. Default=500 \" , \" height \" : \" Height of cropped files in px. Default=500 \" , \" y \" : \" Bypass any confirmation prompts \" , \" facePercent \" : \" Percentage of face to image height \" , \" no_resize \" : \"\"\" Do not resize images to the specified width and height, but instead use the original image ' s pixels.\"\"\", } parser = argparse . ArgumentParser ( description = help_d [ \" desc \" ] ) parser . add_argument ( \" -v \" , \" --version \" , action = \" version \" , version = \" %(prog)s version {} \" . format ( __version__ ) , ) parser . add_argument ( \" --no-confirm \" , action = \" store_true \" , help = help_d [ \" y \" ] ) parser . add_argument ( \" -n \" , \" --no-resize \" , action = \" store_true \" , help = help_d [ \" no_resize \" ], ) parser . add_argument ( \" -i \" , \" --input \" , default = \" . \" , type = input_path , help = help_d [ \" input \" ] ) parser . add_argument ( \" -o \" , \" --output \" , \" -p \" , \" --path \" , type = output_path , default = None , help = help_d [ \" output \" ], ) parser . add_argument ( \" -r \" , \" --reject \" , type = output_path , default = None , help = help_d [ \" reject \" ] ) parser . add_argument ( \" -w \" , \" --width \" , type = size , default = 500 , help = help_d [ \" width \" ] ) parser . add_argument ( \" -H \" , \" --height \" , type = size , default = 500 , help = help_d [ \" height \" ] ) parser . add_argument ( \" --facePercent \" , type = size , default = 50 , help = help_d [ \" facePercent \" ] ) parser . add_argument ( \" -e \" , \" --extension \" , type = chk_extension , default = None , help = help_d [ \" extension \" ] ) return parser . parse_args ()","title":"parse_args"},{"location":"reference/autocrop/cli/#reject","text":"def reject ( input_filename , reject_filename ) Move the input file to the reject location. View Source def reject ( input_filename , reject_filename ) : \"\"\" Move the input file to the reject location. \"\"\" if input_filename != reject_filename : # Move the file to the reject directory shutil . copy ( input_filename , reject_filename )","title":"reject"},{"location":"reference/autocrop/cli/#size","text":"def size ( i ) Returns valid only if input is a positive integer under 1e5 View Source def size ( i ) : \"\"\" Returns valid only if input is a positive integer under 1e5 \"\"\" error = \" Invalid pixel size \" try : i = int ( i ) except ValueError : raise argparse . ArgumentTypeError ( error ) if i > 0 and i < 1 e5 : return i else : raise argparse . ArgumentTypeError ( error )","title":"size"},{"location":"reference/autocrop/constants/","text":"Module autocrop.constants None None View Source FIXEXP = True # Flag to fix underexposition MINFACE = 8 # Minimum face size ratio; too low and we get false positives INCREMENT = 0.06 GAMMA_THRES = 0.001 GAMMA = 0.90 FACE_RATIO = 6 # Face / padding ratio QUESTION_OVERWRITE = \"Overwrite image files?\" # File types supported by OpenCV CV2_FILETYPES = [ \".bmp\", \".dib\", \".jp2\", \".jpe\", \".jpeg\", \".jpg\", \".pbm\", \".pgm\", \".png\", \".ppm\", \".ras\", \".sr\", \".tif\", \".tiff\", \".webp\", ] # File types supported by Pillow PILLOW_FILETYPES = [ \".eps\", \".gif\", \".icns\", \".ico\", \".im\", \".msp\", \".pcx\", \".sgi\", \".spi\", \".xbm\", ] CASCFILE = \"haarcascade_frontalface_default.xml\" Variables CASCFILE CV2_FILETYPES FACE_RATIO FIXEXP GAMMA GAMMA_THRES INCREMENT MINFACE PILLOW_FILETYPES QUESTION_OVERWRITE","title":"Constants"},{"location":"reference/autocrop/constants/#module-autocropconstants","text":"None None View Source FIXEXP = True # Flag to fix underexposition MINFACE = 8 # Minimum face size ratio; too low and we get false positives INCREMENT = 0.06 GAMMA_THRES = 0.001 GAMMA = 0.90 FACE_RATIO = 6 # Face / padding ratio QUESTION_OVERWRITE = \"Overwrite image files?\" # File types supported by OpenCV CV2_FILETYPES = [ \".bmp\", \".dib\", \".jp2\", \".jpe\", \".jpeg\", \".jpg\", \".pbm\", \".pgm\", \".png\", \".ppm\", \".ras\", \".sr\", \".tif\", \".tiff\", \".webp\", ] # File types supported by Pillow PILLOW_FILETYPES = [ \".eps\", \".gif\", \".icns\", \".ico\", \".im\", \".msp\", \".pcx\", \".sgi\", \".spi\", \".xbm\", ] CASCFILE = \"haarcascade_frontalface_default.xml\"","title":"Module autocrop.constants"},{"location":"reference/autocrop/constants/#variables","text":"CASCFILE CV2_FILETYPES FACE_RATIO FIXEXP GAMMA GAMMA_THRES INCREMENT MINFACE PILLOW_FILETYPES QUESTION_OVERWRITE","title":"Variables"}]}